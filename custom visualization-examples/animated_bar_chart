<style>
    text {
        font-size: 16px;
        font-family: Open Sans, sans-serif;
    }

    text.title {
        font-size: 24px;
        font-weight: 500;
    }

    text.subTitle {
        font-weight: 500;
        fill: #777777;
    }

    text.caption {
        font-weight: 400;
        font-size: 14px;
        fill: #777777;
    }

    text.label {
        font-weight: 100;
        font-size: 12px;
    }

    text.valueLabel {
        font-weight: 300;
    }

    text.dateText {
        font-size: 64px;
        font-weight: 700;
        opacity: 0.25;
    }

    .tick text {
        fill: #777777;
    }

    .xAxis .tick:nth-child(2) text {
        text-anchor: start;
    }

    .tick line {
        shape-rendering: CrispEdges;
        stroke: #dddddd;
    }

    .tick line.origin {
        stroke: #aaaaaa;
    }

    path.domain {
        display: none;
    }

    #custom-viz {
        height: 90vh;
        width: 90vw;
    }
</style>
<div id="custom-viz"></div>
<script>
    var timelineData = {{_data}};
    var iframe = document.getElementsByTagName('iframe');
    for (i = 0; i < iframe.length; i++) {
        var innerDoc = iframe[i].contentDocument || iframe[i].contentWindow.document;
    }
    var presentation$ = innerDoc.getElementById('custom-viz');

    var height = presentation$.offsetHeight;
    var width = presentation$.offsetWidth;

    var svg = d3.select(presentation$).append("svg")
        .attr("width", width)
        .attr("height", height);

    var tickDuration = 1500;

    var top_n = 8;

    const margin = {
        top: 80,
        right: 0,
        bottom: 5,
        left: 5
    };

    let barPadding = (height - (margin.bottom + margin.top)) / (top_n * 5);
    let date, minDate, maxDate;

    const halo = function (text, strokeWidth) {
        text.select(function () {
            return this.parentNode.insertBefore(this.cloneNode(true), this);
        })
            .style('fill', '#ffffff')
            .style('stroke', '#ffffff')
            .style('stroke-width', strokeWidth)
            .style('stroke-linejoin', 'round')
            .style('opacity', 1);

    }
    timelineData.forEach(function (d) {
        d.value = parseInt(d.value),
            d.lastValue = isNaN(d.lastValue) ? 0 : parseInt(d.lastValue),
            d.colour = d3.hsl(Math.random() * 360, 0.75, 0.75),
            minDate = (minDate === undefined) ? d.date : (minDate > d.date ? d.date : minDate),
            maxDate = (maxDate === undefined) ? d.date : (maxDate < d.date ? d.date : maxDate)
    });

    date = minDate;

    let dateSlice = timelineData.filter(d => d.date == date && !isNaN(d.value))
        .sort((a, b) => b.Value - a.Value)
        .slice(0, top_n);

    dateSlice.forEach((d, i) => d.rank = i);

    let x = d3.scale.linear()
        .domain([0, d3.max(dateSlice, d => d.value)])
        .range([margin.left, width - margin.right - 65]);
    let y = d3.scale.linear()
        .domain([top_n, 0])
        .range([height - margin.bottom, margin.top]);

    let xAxis = d3.svg.axis().orient("top")
        .scale(x)
        .ticks(width > 500 ? 5 : 2)
        .tickSize(-(height - margin.top - margin.bottom))
        .tickFormat(d => d3.format(',')(d));

    svg.append('g')
        .attr('class', 'axis xAxis')
        .attr('transform', `translate(0, ${margin.top})`)
        .call(xAxis)
        .selectAll('.tick line')
        .classed('origin', d => d == 0);

    svg.selectAll('rect.bar')
        .data(dateSlice, d => d.name)
        .enter()
        .append('rect')
        .attr('class', 'bar')
        .attr('x', x(0) + 1)
        .attr('width', d => x(d.value) - x(0) - 1)
        .attr('y', d => y(d.rank) + 5)
        .attr('height', y(1) - y(0) - barPadding)
        .style('fill', d => d.colour);

    svg.selectAll('text.label')
        .data(dateSlice, d => d.name)
        .enter()
        .append('text')
        .attr('class', 'label')
        .attr('x', d => x(d.value) - 8)
        .attr('y', d => y(d.rank) + 5 + ((y(1) - y(0)) / 2) + 1)
        .style('text-anchor', 'end')
        .html(d => d.name);

    svg.selectAll('text.valueLabel')
        .data(dateSlice, d => d.name)
        .enter()
        .append('text')
        .attr('class', 'valueLabel')
        .attr('x', d => x(d.value) + 5)
        .attr('y', d => y(d.rank) + 5 + ((y(1) - y(0)) / 2) + 1)
        .text(d => d3.format(',.0f')(d.lastValue));

    let dateText = svg.append('text')
        .attr('class', 'dateText')
        .attr('x', width - margin.right)
        .attr('y', height - 25)
        .style('text-anchor', 'end')
        .html(moment(Math.trunc(date)).format('DD MMM'))
        .call(halo, 10);


    let ticker = d3.interval(e => {

        dateSlice = timelineData.filter(d => d.date == date && !isNaN(d.value))
            .sort((a, b) => b.Value - a.Value)
            .slice(0, top_n);

        dateSlice.forEach((d, i) => d.rank = i);


        x.domain([0, d3.max(dateSlice, d => d.value)]);

        svg.select('.xAxis')
            .transition()
            .duration(tickDuration)
            .ease("linear")
            .call(xAxis);

        let bars = svg.selectAll('.bar').data(dateSlice, d => d.name);

        bars
            .enter()
            .append('rect')
            .attr('class', d => `bar ${d.name.replace(/s/g, '_')}`)
            .attr('x', x(0) + 1)
            .attr('width', d => x(d.value) - x(0) - 1)
            .attr('y', d => y(top_n + 1) + 5)
            .attr('height', y(1) - y(0) - barPadding)
            .style('fill', d => d.colour)
            .transition()
            .duration(tickDuration)
            .ease("linear")
            .attr('y', d => y(d.rank) + 5);

        bars
            .transition()
            .duration(tickDuration)
            .ease("linear")
            .attr('width', d => x(d.value) - x(0) - 1)
            .attr('y', d => y(d.rank) + 5);

        bars
            .exit()
            .transition()
            .duration(tickDuration)
            .ease("linear")
            .attr('width', d => x(d.value) - x(0) - 1)
            .attr('y', d => y(top_n + 1) + 5)
            .remove();

        let labels = svg.selectAll('.label')
            .data(dateSlice, d => d.name);

        labels
            .enter()
            .append('text')
            .attr('class', 'label')
            .attr('x', d => x(d.value) - 8)
            .attr('y', d => y(top_n + 1) + 5 + ((y(1) - y(0)) / 2))
            .style('text-anchor', 'end')
            .html(d => d.name)
            .transition()
            .duration(tickDuration)
            .ease("linear")
            .attr('y', d => y(d.rank) + 5 + ((y(1) - y(0)) / 2) + 1);


        labels
            .transition()
            .duration(tickDuration)
            .ease("linear")
            .attr('x', d => x(d.value) - 8)
            .attr('y', d => y(d.rank) + 5 + ((y(1) - y(0)) / 2) + 1);

        labels
            .exit()
            .transition()
            .duration(tickDuration)
            .ease("linear")
            .attr('x', d => x(d.value) - 8)
            .attr('y', d => y(top_n + 1) + 5)
            .remove();


        let valueLabels = svg.selectAll('.valueLabel').data(dateSlice, d => d.name);

        valueLabels
            .enter()
            .append('text')
            .attr('class', 'valueLabel')
            .attr('x', d => x(d.value) + 5)
            .attr('y', d => y(top_n + 1) + 5)
            .text(d => d3.format(',.0f')(d.lastValue))
            .transition()
            .duration(tickDuration)
            .ease("linear")
            .attr('y', d => y(d.rank) + 5 + ((y(1) - y(0)) / 2) + 1);

        valueLabels
            .transition()
            .duration(tickDuration)
            .ease("linear")
            .attr('x', d => x(d.value) + 5)
            .attr('y', d => y(d.rank) + 5 + ((y(1) - y(0)) / 2) + 1)
            .tween("text", function (d) {
                let i = d3.interpolateRound(d.lastValue, d.value);
                return function (t) {
                    this.textContent = d3.format(',')(i(t));
                };
            });


        valueLabels
            .exit()
            .transition()
            .duration(tickDuration)
            .ease("linear")
            .attr('x', d => x(d.value) + 25)
            .attr('y', d => y(top_n + 1) + 25)
            .remove();

        dateText.html(moment(Math.trunc(date)).format('DD MMM'));
        if (date == maxDate) ticker.stop();
        date = parseInt(moment.tz(date, 'America/Los_Angeles').add(1, 'days').format('x'));
    }, tickDuration);

</script>
